<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vanishing Point Perspective Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; }
    /* body { margin: 0; overflow: hidden; background: #fff; font-family: sans-serif; } */
    #ui {
      position: absolute;
      left: 10px;
      top: 10px;
      width: 350px;
      background: rgba(30,30,30,0.5);
      /* background: rgba(240,240,240,0.95); */
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    #ui-toggle {
      position: absolute;
      left: 10px;
      bottom: 10px;
      background: rgba(30,30,30,0.5);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    label { font-size: 12px; margin-top: 10px; }
    input { width: 100%; margin-left: auto; margin-right: auto; }
    button { font-size: 16px; background-color: rgba(160,160,160,0.2); border-radius: 4px; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Rotate X<span id="rxDeg"></span><input id="rx" type="range" min="-180" max="180" step="0.5" value="0"></label>
    <label>Rotate Y<span id="ryDeg"></span><input id="ry" type="range" min="-180" max="180" step="0.5" value="0"></label>
    <label>Rotate Z<span id="rzDeg"></span><input id="rz" type="range" min="-180" max="180" step="0.5" value="0"></label>
    <!-- <label>Rotate X<input id="rx" type="range" min="-3.14" max="3.14" step="0.01" value="0.5"></label>
    <label>Rotate Y<input id="ry" type="range" min="-3.14" max="3.14" step="0.01" value="0.7"></label>
    <label>Rotate Z<input id="rz" type="range" min="-3.14" max="3.14" step="0.01" value="0"></label> -->
    <label>Zoom<span id="zoomContent"></span><input id="zoom" type="range" min="1" max="8" step="0.5" value="5"></label>
    <label style="display: inline-block;">Show Ghost<input id="chk_ghost" type="checkbox" checked="true"></label>
    <label style="display: inline-block;">Show 2D Views<input id="chk_2D" type="checkbox" checked="true"></label>
    <label id="lbl_capture" style="display: inline-block; visibility: hidden;">Show Capture<input id="chk_capture" type="checkbox"></label>
    <label style="display: inline-block;">Capture View<button id="btn_capture" style="display: block; margin-left: auto; margin-right: auto;">ðŸ“·</button></label>
  </div>

  <div id="ui-toggle"  style="display: inline-flex;">
    <button title="Toggle UI Panel" onclick="toggleUIPanelVisibility()">â˜°</button>
    <input title="Set UI Transparency" id="ui-slider" type="range" min="1" max="10" step="1" value="6">
  </div>
  <script>
    const ui_panel = document.getElementById("ui");
    const ui_slider = document.getElementById("ui-slider");
    const ui_toggle = document.getElementById("ui-toggle");
    ui_panel.style.opacity = ui_slider.value / 10;
    ui_toggle.style.opacity = ui_slider.value / 10;

    function toggleUIPanelVisibility() {
      (ui_panel.style.display === "none") ? ui_panel.style.display = "" : ui_panel.style.display = "none";
    }
    ui_slider.oninput = function updateUIPanelOpacity() {
      ui_panel.style.opacity = ui_slider.value / 10;
      ui_toggle.style.opacity = ui_slider.value / 10;
    }
  </script>

  <script type="module">
    // https://threejs.org/docs/
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';

    // ---------------- SCENE ----------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x6e6e6e);
    // scene.background = new THREE.Color(0xffffff);

    // ---------------- CAMERAS ----------------
    // By default, all cameras see Layer 0 only.
    function makeLabel(text, x, y) {
      const el = document.createElement('div');
      el.textContent = text;
      el.style.position = 'absolute';
      // el.style.right = x + 'px';
      el.style.top = y + 'px';
      el.style.left = (window.innerWidth - size / 2 - m) + 'px';
      el.style.fontSize = '11px';
      el.style.padding = '4px 6px';
      el.style.background = 'rgba(255,255,255,0.85)';
      el.style.color = 'rgba(0,0,0,0.85)';
      el.style.border = '1px solid rgba(0,0,0,0.2)';
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.7';
      el.style.transform = 'translateX(-50%)';
      document.body.appendChild(el);
      return el;
    }

    const size = Math.min(window.innerWidth, window.innerHeight) * 0.22;
    const m = 16;
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
    const zoom = document.getElementById('zoom');
    camera.position.z = 10 - zoom.value;
    camera.layers.enable(0);
    camera.layers.enable(1);
    camera.layers.enable(2);
    camera.layers.enable(3);
    
    const lbl_2D = makeLabel('ORTHOGRAPHIC - 2D VIEWS', size/2, 10);
    const orthoSize = 3;
    const camTop = new THREE.OrthographicCamera(-orthoSize, orthoSize, orthoSize, -orthoSize, 0.1, 10000);
    camTop.position.set(0, 50, 0);
    // camTop.up.set(0, 0, -1);
    camTop.lookAt(0, 0, 0);
    const lbl_top = makeLabel('TOP', size/2, size - m);
    
    const camSideX = new THREE.OrthographicCamera(-orthoSize, orthoSize, orthoSize, -orthoSize, 0.1, 10000);
    camSideX.position.set(-50, 0, 0);
    // camSideX.up.set(0, 0, -1);
    camSideX.lookAt(0, 0, 0);
    const lbl_side = makeLabel('SIDE', size/2, size * 2);
    
    const camSideZ = new THREE.OrthographicCamera(-orthoSize, orthoSize, orthoSize, -orthoSize, 0.1, 10000);
    camSideZ.position.set(0, 0, 50);
    // camSideZ.up.set(0, 0, -1);
    camSideZ.lookAt(0, 0, 0);
    const lbl_front = makeLabel('FRONT', size/2-m/2, size * 3.1);


    // ---------------- RENDERER ----------------
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // ---------------- OBJECTS ----------------

    // AXES
    const axes = new THREE.AxesHelper(0.5);
    axes.alpha = true;
    axes.transparent = true;
    axes.opacity = 0.5;
    scene.add(axes);

    // CUBE
    const extent = 3000;
    const s = 1;
    const cube_extent = 1;

    const box = new THREE.Mesh(
      new THREE.BoxGeometry(2, 2, 2),
      new THREE.MeshBasicMaterial({ color: 0x5555ff, transparent: true, opacity: 0.35, depthWrite: false})
    );
    box.layers.set(0);

    const cube_lines_ghost = [
      [[-s,s,s],[s,s,s]],
      [[-s,-s,s],[s,-s,s]],
      [[s,-s,s],[s,s,s]],
      [[-s,-s,s],[-s,s,s]]
    ];
    const cube_lines_top = [
      [[-s,s,-s],[s,s,-s]],
      [[-s,s,s],[s,s,s]],
      [[-s,s,-s],[-s,s,s]],
      [[s,s,-s],[s,s,s]]
    ];
    const cube_lines_bot = [
      [[-s,-s,-s],[s,-s,-s]],
      [[-s,-s,s],[s,-s,s]],
      [[-s,-s,-s],[-s,-s,s]],
      [[s,-s,-s],[s,-s,s]]
    ];
    const cube_lines_sides = [
      [[-s,-s,-s],[-s,s,-s]], [[s,-s,-s],[s,s,-s]],
      [[-s,-s,s],[-s,s,s]], [[s,-s,s],[s,s,s]]
    ];
    const cube_lines_group = new THREE.Group();
    const cube_lines_ghost_group = new THREE.Group();
    const cube_lines_mat_ghost = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.15});
    const cube_lines_mat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5});
    const cube_lines_mat_top = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.7});
    const cube_lines_mat_sides = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7});
    const cube_lines_mat_bot = new THREE.LineBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.7});
    // const cube_lines_mat = new THREE.LineBasicMaterial({ color: 0x5555ff, transparent: true, opacity: 0.5});
    
    cube_lines_ghost.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, cube_lines_mat_ghost);
      new_line.layers.set(2);
      cube_lines_ghost_group.add(new_line);
    });
    
    cube_lines_top.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, cube_lines_mat_top);
      cube_lines_group.add(new_line);
    });

    cube_lines_sides.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, cube_lines_mat_sides);
      cube_lines_group.add(new_line);
    });

    cube_lines_bot.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, cube_lines_mat_bot);
      cube_lines_group.add(new_line);
    });
    scene.add(cube_lines_group);
    const box_group = new THREE.Group();
    box_group.add(cube_lines_group);
    scene.add(box_group);
    scene.add(cube_lines_ghost_group);

    const lines = [
      [[-extent,-s,-s],[extent,-s,-s]], [[-extent,s,-s],[extent,s,-s]],
      [[-extent,-s,s],[extent,-s,s]], [[-extent,s,s],[extent,s,s]],
      [[-s,-extent,-s],[-s,extent,-s]], [[s,-extent,-s],[s,extent,-s]],
      [[-s,-extent,s],[-s,extent,s]], [[s,-extent,s],[s,extent,s]],
      [[-s,-s,-extent],[-s,-s,extent]], [[s,-s,-extent],[s,-s,extent]],
      [[-s,s,-extent],[-s,s,extent]], [[s,s,-extent],[s,s,extent]]
    ];

    // CUBE VANISHING LINES
    const group = new THREE.Group();
    const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
    // const mat = new THREE.LineBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.2 });

    lines.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, mat);
      new_line.layers.set(0);
      new_line.layers.set(1);
      group.add(new_line);
    });

    const horizon = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.CircleGeometry(extent, 32)), mat);
    horizon.rotateX(THREE.MathUtils.degToRad('90'));
    horizon.layers.set(1);
    group.add(horizon);
    scene.add(group);

    // SPHERE
    const radius = Math.sqrt(3);
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(radius, 64, 48),
      new THREE.MeshBasicMaterial({
        // color: 0x999999,
        color: 0xc7c7c7,
        transparent: true,
        opacity: 0.2,
        depthWrite: false
      })
    );
    sphere.layers.set(0);
    scene.add(sphere);



    // ---------------- VIEW STATE ----------------
    // const rotation = { x: 0.5, y: 0.7, z: 0 };
    const rotation = { x: 0, y: 0, z: 0 };

    const ry = document.getElementById('rx');
    const rz = document.getElementById('ry');
    const rx = document.getElementById('rz');
    const ryDeg = document.getElementById('rxDeg');
    const rzDeg = document.getElementById('ryDeg');
    const rxDeg = document.getElementById('rzDeg');
    const zoomContent = document.getElementById('zoomContent');
    const showGhost = document.getElementById('chk_ghost');
    const show2D = document.getElementById('chk_2D');
    // const zoom = document.getElementById('zoom');
    
    function updateSlidersText() {
      rxDeg.textContent = ' (' + THREE.MathUtils.radToDeg(rotation.x).toFixed(2) + 'Â° )';
      ryDeg.textContent = ' (' + THREE.MathUtils.radToDeg(rotation.y).toFixed(2) + 'Â° )';
      rzDeg.textContent = ' (' + THREE.MathUtils.radToDeg(rotation.z).toFixed(2) + 'Â° )';
    }

    function applyRotation() {
      if (THREE.MathUtils.radToDeg(rotation.y) < -180) {
        rotation.y = THREE.MathUtils.degToRad(-180);
      } else if (THREE.MathUtils.radToDeg(rotation.y) > 180) {
        rotation.y = THREE.MathUtils.degToRad(180);
      };
      if (THREE.MathUtils.radToDeg(rotation.x) < -180) {
        rotation.x = THREE.MathUtils.degToRad(-180);
      } else if (THREE.MathUtils.radToDeg(rotation.x) > 180) {
        rotation.x = THREE.MathUtils.degToRad(180);
      };
      if (THREE.MathUtils.radToDeg(rotation.z) < -180) {
        rotation.z = THREE.MathUtils.degToRad(-180);
      } else if (THREE.MathUtils.radToDeg(rotation.z) > 180) {
        rotation.z = THREE.MathUtils.degToRad(180);
      };

      group.rotation.set(rotation.x, rotation.y, rotation.z);
      box_group.rotation.copy(group.rotation);
      sphere.rotation.copy(group.rotation);
      axes.rotation.copy(group.rotation);

      rx.value = THREE.MathUtils.radToDeg(rotation.x);
      ry.value = THREE.MathUtils.radToDeg(rotation.y);
      rz.value = THREE.MathUtils.radToDeg(rotation.z);

      updateSlidersText();
    }

    rx.addEventListener('input', () => { rotation.x = THREE.MathUtils.degToRad(+rx.value); applyRotation(); });
    ry.addEventListener('input', () => { rotation.y = THREE.MathUtils.degToRad(+ry.value); applyRotation(); });
    rz.addEventListener('input', () => { rotation.z = THREE.MathUtils.degToRad(+rz.value); applyRotation(); });
    showGhost.addEventListener('input', () => {
      if (showGhost.checked) {
        camera.layers.enable(2);
      } else {
        camera.layers.disable(2);
      }
    });
    show2D.addEventListener('input', () => {
      if (show2D.checked) {
        lbl_2D.style.visibility = 'visible';
        lbl_top.style.visibility = 'visible';
        lbl_side.style.visibility = 'visible';
        lbl_front.style.visibility = 'visible';
      } else {
        lbl_2D.style.visibility = 'hidden';
        lbl_top.style.visibility = 'hidden';
        lbl_side.style.visibility = 'hidden';
        lbl_front.style.visibility = 'hidden';
      }
    });

    zoom.addEventListener('input', () => {
      camera.position.z = 10 - zoom.value;
      camera.lookAt(0,0,0);
    });

    applyRotation();

    // ---------------- CAPTURE VIEW ----------------
    const btn_capture = document.getElementById("btn_capture");
    const chk_capture = document.getElementById("chk_capture");
    const lbl_capture = document.getElementById("lbl_capture");
    const capture_edges = new THREE.EdgesGeometry(box.geometry);
    const capture_line_mat = new THREE.LineBasicMaterial({ color: 0x820071, transparent: true, opacity: 0.25 });
    const capture_linesegs = new THREE.LineSegments(capture_edges, capture_line_mat);
    btn_capture.addEventListener('click', () => {
      capture_linesegs.rotation.copy(box_group.rotation);
      capture_linesegs.layers.set(3);
      scene.add(capture_linesegs);
      lbl_capture.style.visibility = "visible";
      chk_capture.checked = true;
      toggleCapture();
    });

    function toggleCapture() {
      if (chk_capture.checked) {
        camera.layers.enable(3);
      } else {
        camera.layers.disable(3);
      }
    }

    chk_capture.addEventListener('input', toggleCapture);

    // ---------------- MOUSE ROTATION ----------------
    let down = false, lx = 0, ly = 0;
    renderer.domElement.addEventListener('mousedown', e => { down = true; lx = e.clientX; ly = e.clientY; });
    window.addEventListener('mouseup', () => down = false);
    window.addEventListener('mousemove', e => {
      if (!down) return;
      rotation.y += (e.clientX - lx) * 0.005;
      rotation.x += (e.clientY - ly) * 0.005;
      applyRotation();
      lx = e.clientX; ly = e.clientY;
    });

    // ---------------- MOBILE CONTROLS ----------------
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    renderer.domElement.addEventListener('touchstart', e => {
      down = true;
      lx = e.touches[0].clientX;
      ly = e.touches[0].clientY;
    });

    renderer.domElement.addEventListener('touchmove', e => {
      if (!down) return;
      rotation.y += (e.touches[0].clientX - lx) * 0.005;
      rotation.x += (e.touches[0].clientY - ly) * 0.005;
      applyRotation();
      lx = e.touches[0].clientX;
      ly = e.touches[0].clientY;
    });

    renderer.domElement.addEventListener('touchend', () => down = false);

    // ---------------- RENDER LOOP (MULTI VIEW) ----------------
    function renderView(cam, x, y, w, h) {
      renderer.setViewport(x, y, w, h);
      renderer.setScissor(x, y, w, h);
      renderer.render(scene, cam);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.setScissorTest(true);
      
      // Main view
      renderView(camera, 0, 0, window.innerWidth, window.innerHeight);
      
      if (show2D.checked) {
        // Top view
        renderView(camTop,
          window.innerWidth - size - m,
          window.innerHeight - size - m,
          size, size
        );
  
        // Side X
        renderView(camSideX,
          window.innerWidth - size - m,
          window.innerHeight - size * 2 - m * 2,
          size, size
        );
  
        // Side Z
        renderView(camSideZ,
          window.innerWidth - size - m,
          window.innerHeight - size * 3 - m * 3,
          size, size
        );
      };
    }

    animate();
  </script>

  <div style="position:fixed; bottom:8px; right:8px; font-size:10px; color:#999;">Built with Three.js</div>

</body>
</html>

<!--
Uses Three.js (MIT License)
https://threejs.org/
-->
