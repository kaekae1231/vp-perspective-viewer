<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cube with Infinite Extrusions + Multi-View</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; }
    /* body { margin: 0; overflow: hidden; background: #fff; font-family: sans-serif; } */
    #ui {
      position: absolute;
      left: 10px;
      top: 10px;
      width: 180px;
      background: rgba(30,30,30,0.9);
      /* background: rgba(240,240,240,0.95); */
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    label { font-size: 12px; display: block; margin-top: 10px; }
    input { width: 100%; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Rotate X<span id="rxDeg"></span><input id="rx" type="range" min="-180" max="180" step="0.5" value="0"></label>
    <label>Rotate Y<span id="ryDeg"></span><input id="ry" type="range" min="-180" max="180" step="0.5" value="0"></label>
    <label>Rotate Z<span id="rzDeg"></span><input id="rz" type="range" min="-180" max="180" step="0.5" value="0"></label>
    <!-- <label>Rotate X<input id="rx" type="range" min="-3.14" max="3.14" step="0.01" value="0.5"></label>
    <label>Rotate Y<input id="ry" type="range" min="-3.14" max="3.14" step="0.01" value="0.7"></label>
    <label>Rotate Z<input id="rz" type="range" min="-3.14" max="3.14" step="0.01" value="0"></label> -->
    <label>Zoom<input id="zoom" type="range" min="1" max="8" step="0.5" value="5"></label>
  </div>

  <script type="module">
    // https://threejs.org/docs/
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';

    // ---------------- SCENE ----------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x6e6e6e);
    // scene.background = new THREE.Color(0xffffff);

    // ---------------- CAMERAS ----------------
    function makeLabel(text, x, y) {
      const el = document.createElement('div');
      el.textContent = text;
      el.style.position = 'absolute';
      // el.style.right = x + 'px';
      el.style.top = y + 'px';
      el.style.left = (window.innerWidth - size / 2 - m) + 'px';
      el.style.fontSize = '11px';
      el.style.padding = '4px 6px';
      el.style.background = 'rgba(255,255,255,0.85)';
      el.style.color = 'rgba(0,0,0,0.85)';
      el.style.border = '1px solid rgba(0,0,0,0.2)';
      el.style.pointerEvents = 'none';
      el.style.opacity = '0.7';
      el.style.transform = 'translateX(-50%)';
      document.body.appendChild(el);
      return el;
    }

    const size = Math.min(window.innerWidth, window.innerHeight) * 0.22;
    const m = 16;
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
    const zoom = document.getElementById('zoom');
    camera.position.z = 10 - zoom.value;
    camera.layers.enable(0);
    camera.layers.enable(1);

    
    makeLabel('ORTHOGRAPHIC - 2D VIEWS', size/2, 10);
    const orthoSize = 3;
    const camTop = new THREE.OrthographicCamera(-orthoSize, orthoSize, orthoSize, -orthoSize, 0.1, 10000);
    camTop.position.set(0, 50, 0);
    // camTop.up.set(0, 0, -1);
    camTop.lookAt(0, 0, 0);
    makeLabel('TOP', size/2, size - m);
    
    const camSideX = new THREE.OrthographicCamera(-orthoSize, orthoSize, orthoSize, -orthoSize, 0.1, 10000);
    camSideX.position.set(-50, 0, 0);
    // camSideX.up.set(0, 0, -1);
    camSideX.lookAt(0, 0, 0);
    makeLabel('SIDE', size/2, size * 2);
    
    const camSideZ = new THREE.OrthographicCamera(-orthoSize, orthoSize, orthoSize, -orthoSize, 0.1, 10000);
    camSideZ.position.set(0, 0, 50);
    // camSideZ.up.set(0, 0, -1);
    camSideZ.lookAt(0, 0, 0);
    makeLabel('FRONT', size/2-m/2, size * 3.1);


    // ---------------- RENDERER ----------------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // ---------------- OBJECTS ----------------

    // AXES
    const axes = new THREE.AxesHelper(1);
    scene.add(axes);

    // CUBE
    const extent = 3000;
    const s = 1;
    const cube_extent = 1;

    const box = new THREE.Mesh(
      new THREE.BoxGeometry(2, 2, 2),
      new THREE.MeshBasicMaterial({ color: 0x5555ff, transparent: true, opacity: 0.35, depthWrite: false})
    );
    box.layers.set(0);

    const cube_lines = [
      [[s,s,-s],[s,s,s]]
    ];
    const cube_lines_top = [
      [[-s,s,-s],[s,s,-s]],
      [[-s,s,s],[s,s,s]],
      [[-s,s,-s],[-s,s,s]],
      [[s,s,-s],[s,s,s]]
    ];
    const cube_lines_bot = [
      [[-s,-s,-s],[s,-s,-s]],
      [[-s,-s,s],[s,-s,s]],
      [[-s,-s,-s],[-s,-s,s]],
      [[s,-s,-s],[s,-s,s]]
    ];
    const cube_lines_sides = [
      [[-s,-s,-s],[-s,s,-s]], [[s,-s,-s],[s,s,-s]],
      [[-s,-s,s],[-s,s,s]], [[s,-s,s],[s,s,s]]
    ];
    const cube_lines_group = new THREE.Group();
    const cube_lines_mat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5});
    const cube_lines_mat_top = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5});
    const cube_lines_mat_sides = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5});
    const cube_lines_mat_bot = new THREE.LineBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5});
    // const cube_lines_mat = new THREE.LineBasicMaterial({ color: 0x5555ff, transparent: true, opacity: 0.5});
    
    // cube_lines.forEach(([a,b]) => {
    //   const g = new THREE.BufferGeometry().setFromPoints([
    //     new THREE.Vector3(...a), new THREE.Vector3(...b)
    //   ]);
    //   const new_line = new THREE.Line(g, cube_lines_mat);
    //   cube_lines_group.add(new_line);
    // });
    
    cube_lines_top.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, cube_lines_mat_top);
      cube_lines_group.add(new_line);
    });

    cube_lines_sides.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, cube_lines_mat_sides);
      cube_lines_group.add(new_line);
    });

    cube_lines_bot.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, cube_lines_mat_bot);
      cube_lines_group.add(new_line);
    });
    scene.add(cube_lines_group);
    const box_group = new THREE.Group();
    box_group.add(cube_lines_group)
    scene.add(box_group);

    const lines = [
      [[-extent,-s,-s],[extent,-s,-s]], [[-extent,s,-s],[extent,s,-s]],
      [[-extent,-s,s],[extent,-s,s]], [[-extent,s,s],[extent,s,s]],
      [[-s,-extent,-s],[-s,extent,-s]], [[s,-extent,-s],[s,extent,-s]],
      [[-s,-extent,s],[-s,extent,s]], [[s,-extent,s],[s,extent,s]],
      [[-s,-s,-extent],[-s,-s,extent]], [[s,-s,-extent],[s,-s,extent]],
      [[-s,s,-extent],[-s,s,extent]], [[s,s,-extent],[s,s,extent]]
    ];

    // CUBE VANISHING LINES
    const group = new THREE.Group();
    const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
    // const mat = new THREE.LineBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.2 });

    lines.forEach(([a,b]) => {
      const g = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(...a), new THREE.Vector3(...b)
      ]);
      const new_line = new THREE.Line(g, mat);
      new_line.layers.set(0);
      new_line.layers.set(1);
      group.add(new_line);
    });
    scene.add(group);

    // SPHERE
    const radius = Math.sqrt(3);
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(radius, 64, 48),
      new THREE.MeshBasicMaterial({
        // color: 0x999999,
        color: 0xc7c7c7,
        transparent: true,
        opacity: 0.2,
        depthWrite: false
      })
    );
    sphere.layers.set(0);
    scene.add(sphere);



    // ---------------- ROTATION STATE ----------------
    const rotation = { x: 0.5, y: 0.7, z: 0 };

    const ry = document.getElementById('rx');
    const rz = document.getElementById('ry');
    const rx = document.getElementById('rz');
    const ryDeg = document.getElementById('rxDeg');
    const rzDeg = document.getElementById('ryDeg');
    const rxDeg = document.getElementById('rzDeg');
    // const zoom = document.getElementById('zoom');
    
    function updateSlidersText() {
      rxDeg.textContent = ' (' + THREE.MathUtils.radToDeg(rotation.x).toFixed(1) + '° )';
      ryDeg.textContent = ' (' + THREE.MathUtils.radToDeg(rotation.y).toFixed(1) + '° )';
      rzDeg.textContent = ' (' + THREE.MathUtils.radToDeg(rotation.z).toFixed(1) + '° )';
    }

    function applyRotation() {
      if (THREE.MathUtils.radToDeg(rotation.y) < -180) {
        rotation.y = THREE.MathUtils.degToRad(-180);
      } else if (THREE.MathUtils.radToDeg(rotation.y) > 180) {
        rotation.y = THREE.MathUtils.degToRad(180);
      };
      if (THREE.MathUtils.radToDeg(rotation.x) < -180) {
        rotation.x = THREE.MathUtils.degToRad(-180);
      } else if (THREE.MathUtils.radToDeg(rotation.x) > 180) {
        rotation.x = THREE.MathUtils.degToRad(180);
      };
      if (THREE.MathUtils.radToDeg(rotation.z) < -180) {
        rotation.z = THREE.MathUtils.degToRad(-180);
      } else if (THREE.MathUtils.radToDeg(rotation.z) > 180) {
        rotation.z = THREE.MathUtils.degToRad(180);
      };

      group.rotation.set(rotation.x, rotation.y, rotation.z);
      box_group.rotation.copy(group.rotation);
      sphere.rotation.copy(group.rotation);
      axes.rotation.copy(group.rotation);

      rx.value = THREE.MathUtils.radToDeg(rotation.x);
      ry.value = THREE.MathUtils.radToDeg(rotation.y);
      rz.value = THREE.MathUtils.radToDeg(rotation.z);

      updateSlidersText();
    }

    rx.addEventListener('input', () => { rotation.x = THREE.MathUtils.degToRad(+rx.value); applyRotation(); });
    ry.addEventListener('input', () => { rotation.y = THREE.MathUtils.degToRad(+ry.value); applyRotation(); });
    rz.addEventListener('input', () => { rotation.z = THREE.MathUtils.degToRad(+rz.value); applyRotation(); });

    zoom.addEventListener('input', () => {
      camera.position.z = 10 - zoom.value;
      camera.lookAt(0,0,0);
    });

    applyRotation();

    // ---------------- MOUSE ROTATION ----------------
    let down = false, lx = 0, ly = 0;
    renderer.domElement.addEventListener('mousedown', e => { down = true; lx = e.clientX; ly = e.clientY; });
    window.addEventListener('mouseup', () => down = false);
    window.addEventListener('mousemove', e => {
      if (!down) return;
      rotation.y += (e.clientX - lx) * 0.005;
      rotation.x += (e.clientY - ly) * 0.005;
      applyRotation();
      lx = e.clientX; ly = e.clientY;
    });

    // ---------------- MOBILE CONTROLS ----------------
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    renderer.domElement.addEventListener('touchstart', e => {
      down = true;
      lx = e.touches[0].clientX;
      ly = e.touches[0].clientY;
    });

    renderer.domElement.addEventListener('touchmove', e => {
      if (!down) return;
      rotation.y += (e.touches[0].clientX - lx) * 0.005;
      rotation.x += (e.touches[0].clientY - ly) * 0.005;
      applyRotation();
      lx = e.touches[0].clientX;
      ly = e.touches[0].clientY;
    });

    renderer.domElement.addEventListener('touchend', () => down = false);

    // ---------------- RENDER LOOP (MULTI VIEW) ----------------
    function renderView(cam, x, y, w, h) {
      renderer.setViewport(x, y, w, h);
      renderer.setScissor(x, y, w, h);
      renderer.render(scene, cam);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      renderer.setScissorTest(true);
      
      // Main view
      renderView(camera, 0, 0, window.innerWidth, window.innerHeight);
      
      
      // Top view
      renderView(camTop,
        window.innerWidth - size - m,
        window.innerHeight - size - m,
        size, size
      );

      // Side X
      renderView(camSideX,
        window.innerWidth - size - m,
        window.innerHeight - size * 2 - m * 2,
        size, size
      );

      // Side Z
      renderView(camSideZ,
        window.innerWidth - size - m,
        window.innerHeight - size * 3 - m * 3,
        size, size
      );
    }

    animate();
  </script>

  <div style="
    position:fixed;
    bottom:8px;
    right:8px;
    font-size:10px;
    color:#999;
  ">
  Built with Three.js
  </div>

</body>
</html>

<!--
Uses Three.js (MIT License)
https://threejs.org/
-->
